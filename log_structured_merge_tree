A LSMT é uma estrutura de dados desenvolvida para permitir indexação de baixo custo para uma aplicação com altas taxas de inserções e remoçoes, prezando pelo desempenho e performance do sistema. Segundo Patrick O’Neil, uma LSMT de dois níveis (C0 e C1) compreende duas estruturas semelhantes a árvores. C0 é menor e armazenado em memória, C1 é armazenado em disco. Caso novos registros inseridos em C0 exceda seu tamanho, eles são enviados a C1. Isso reduz o tamanho de C0 e cria um novo bloco de C1, gravado em disco.
As operações de inserção de dados são enviadas para o Commit Log, em disco, e só então são executadas em memória principal. Na memória, os dados são armazenados em Memory Table, que são nada mais que tabelas Hash e portanto as operações de acesso/insercao são mais rapidos do que acessar os arquivos diretamente. Em caso de reinicialização do sistema, a Memory Table é restaurada através do Commit Log. Caso o Commit Log seja muito extenso, pode-se criar Snapshots da Memory Table de forma sincronizada com a escrita no Log. Ou seja, se houver uma reinicialização, primeiro restaura o Snapshot e então o novo Log.

Na nossa aplicação de Chat, utilizamos a LSMT para armazenar as mensagens trocadas pelos usuarios, os dados dos usuarios em si e os matches(propostas de emprego). Além do sistema fazer o flush dos dados assim que atingir um certo numero de limite de operações, também criamos uma tarefa assincrona que a cada certo periodo de tempo tambem realiza o flush, mesmo que a memtable não esteja cheia. Caso haja uma falha no servidor e o mesmo venha a parar, primeiro é restaurado o arquivo de snapshot mais recente e depois o log se houver algum é restaurado por cima do Snapshot.

No arquivo de log, armazenamos cada insert/update em uma linha separada para facilitar o append de dados ao arquivo, enquanto que no arquivo de snapshot, é criado um objeto json, com todas as operações contidas no arquivo de log.

Ref.: https://www.cs.umb.edu/~poneil/lsmtree.pdf
